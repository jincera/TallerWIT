<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
   <meta http-equiv="content-type" content="text/html;charset=UTF-8">
   <style type="text/css">
   /*CSS stylesheet is based on killwing's flavored markdown style:https://gist.github.com/2937864*/body{    margin: 0 auto;    font: 13px/1.231 Helvetica, Arial, sans-serif;    color: #444444;    line-height: 1;    max-width: 960px;    padding: 5px;}h1, h2, h3, h4 {    color: #111111;    font-weight: 400;}h1, h2, h3, h4, h5, p {    margin-bottom: 16px;    padding: 0;}h1 {    font-size: 28px;}h2 {    font-size: 22px;    margin: 20px 0 6px;}h3 {    font-size: 21px;}h4 {    font-size: 18px;}h5 {    font-size: 16px;}a {    color: #0099ff;    margin: 0;    padding: 0;    vertical-align: baseline;}a:link,a:visited{ text-decoration:none;}a:hover{ text-decoration:underline;}ul, ol {    padding: 0;    margin: 0;}li {    line-height: 24px;    margin-left: 44px;}li ul, li ul {    margin-left: 24px;}ul, ol {    font-size: 14px;    line-height: 20px;    max-width: 540px;}p {    font-size: 14px;    line-height: 20px;    max-width: 540px;    margin-top: 3px;}pre {    padding: 0px 4px;    max-width: 800px;    white-space: pre-wrap;    font-family: Consolas, Monaco, Andale Mono, monospace;    line-height: 1.5;    font-size: 13px;    border: 1px solid #ddd;    background-color: #f7f7f7;    border-radius: 3px;}code {    font-family: Consolas, Monaco, Andale Mono, monospace;    line-height: 1.5;    font-size: 13px;    border: 1px solid #ddd;    background-color: #f7f7f7;    border-radius: 3px;}pre code {    border: 0px;}aside {    display: block;    float: right;    width: 390px;}blockquote {    border-left:.5em solid #40AA53;    padding: 0 2em;    margin-left:0;    max-width: 476px;}blockquote  cite {    font-size:14px;    line-height:20px;    color:#bfbfbf;}blockquote cite:before {    content: '\2014 \00A0';}blockquote p {      color: #666;    max-width: 460px;}hr {    height: 1px;    border: none;    border-top: 1px dashed #0066CC}button,input,select,textarea {  font-size: 100%;  margin: 0;  vertical-align: baseline;  *vertical-align: middle;}button, input {  line-height: normal;  *overflow: visible;}button::-moz-focus-inner, input::-moz-focus-inner {  border: 0;  padding: 0;}button,input[type="button"],input[type="reset"],input[type="submit"] {  cursor: pointer;  -webkit-appearance: button;}input[type=checkbox], input[type=radio] {  cursor: pointer;}/* override default chrome & firefox settings */input:not([type="image"]), textarea {  -webkit-box-sizing: content-box;  -moz-box-sizing: content-box;  box-sizing: content-box;}input[type="search"] {  -webkit-appearance: textfield;  -webkit-box-sizing: content-box;  -moz-box-sizing: content-box;  box-sizing: content-box;}input[type="search"]::-webkit-search-decoration {  -webkit-appearance: none;}label,input,select,textarea {  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;  font-size: 13px;  font-weight: normal;  line-height: normal;  margin-bottom: 18px;}input[type=checkbox], input[type=radio] {  cursor: pointer;  margin-bottom: 0;}input[type=text],input[type=password],textarea,select {  display: inline-block;  width: 210px;  padding: 4px;  font-size: 13px;  font-weight: normal;  line-height: 18px;  height: 18px;  color: #808080;  border: 1px solid #ccc;  -webkit-border-radius: 3px;  -moz-border-radius: 3px;  border-radius: 3px;}select, input[type=file] {  height: 27px;  line-height: 27px;}textarea {  height: auto;}/* grey out placeholders */:-moz-placeholder {  color: #bfbfbf;}::-webkit-input-placeholder {  color: #bfbfbf;}input[type=text],input[type=password],select,textarea {  -webkit-transition: border linear 0.2s, box-shadow linear 0.2s;  -moz-transition: border linear 0.2s, box-shadow linear 0.2s;  transition: border linear 0.2s, box-shadow linear 0.2s;  -webkit-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);  -moz-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);  box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);}input[type=text]:focus, input[type=password]:focus, textarea:focus {  outline: none;  border-color: rgba(82, 168, 236, 0.8);  -webkit-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(82, 168, 236, 0.6);  -moz-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(82, 168, 236, 0.6);  box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(82, 168, 236, 0.6);}/* buttons */button {  display: inline-block;  padding: 4px 14px;  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;  font-size: 13px;  line-height: 18px;  -webkit-border-radius: 4px;  -moz-border-radius: 4px;  border-radius: 4px;  -webkit-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);  -moz-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);  background-color: #0064cd;  background-repeat: repeat-x;  background-image: -khtml-gradient(linear, left top, left bottom, from(#049cdb), to(#0064cd));  background-image: -moz-linear-gradient(top, #049cdb, #0064cd);  background-image: -ms-linear-gradient(top, #049cdb, #0064cd);  background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #049cdb), color-stop(100%, #0064cd));  background-image: -webkit-linear-gradient(top, #049cdb, #0064cd);  background-image: -o-linear-gradient(top, #049cdb, #0064cd);  background-image: linear-gradient(top, #049cdb, #0064cd);  color: #fff;  text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);  border: 1px solid #004b9a;  border-bottom-color: #003f81;  -webkit-transition: 0.1s linear all;  -moz-transition: 0.1s linear all;  transition: 0.1s linear all;  border-color: #0064cd #0064cd #003f81;  border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);}button:hover {  color: #fff;  background-position: 0 -15px;  text-decoration: none;}button:active {  -webkit-box-shadow: inset 0 3px 7px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);  -moz-box-shadow: inset 0 3px 7px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);  box-shadow: inset 0 3px 7px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);}button::-moz-focus-inner {  padding: 0;  border: 0;}/* table  */table {    border-spacing: 0;    border: 1px solid #ccc;}td, th{    border: 1px solid #ccc;    padding: 5px;}/* code syntax highlight.Documentation: http://www.mdcharm.com/documentation/code_syntax_highlighting.html#custom_your_own */pre .literal,pre .comment,pre .template_comment,pre .diff .header,pre .javadoc {    color: #008000;}pre .keyword,pre .css .rule .keyword,pre .winutils,pre .javascript .title,pre .nginx .title,pre .subst,pre .request,pre .status {    color: #0000FF;    font-weight: bold}pre .number,pre .hexcolor,pre .python .decorator,pre .ruby .constant {    color: #0000FF;}pre .string,pre .tag .value,pre .phpdoc,pre .tex .formula {    color: #D14}pre .title,pre .id {    color: #900;    font-weight: bold}pre .javascript .title,pre .lisp .title,pre .clojure .title,pre .subst {    font-weight: normal}pre .class .title,pre .haskell .type,pre .vhdl .literal,pre .tex .command {    color: #458;    font-weight: bold}pre .tag,pre .tag .title,pre .rules .property,pre .django .tag .keyword {    color: #000080;    font-weight: normal}pre .attribute,pre .variable,pre .lisp .body {    color: #008080}pre .regexp {    color: #009926}pre .class {    color: #458;    font-weight: bold}pre .symbol,pre .ruby .symbol .string,pre .lisp .keyword,pre .tex .special,pre .prompt {    color: #990073}pre .built_in,pre .lisp .title,pre .clojure .built_in {    color: #0086b3}pre .preprocessor,pre .pi,pre .doctype,pre .shebang,pre .cdata {    color: #999;    font-weight: bold}pre .deletion {    background: #fdd}pre .addition {    background: #dfd}pre .diff .change {    background: #0086b3}pre .chunk {    color: #aaa}pre .markdown .header {    color: #800;    font-weight: bold;}pre .markdown .blockquote {    color: #888;}pre .markdown .link_label {    color: #88F;}pre .markdown .strong {    font-weight: bold;}pre .markdown .emphasis {    font-style: italic;}
   </style>
   
   
</head>
<body>
    <h1>Taller FIWARE para Ciudades Inteligentes</h1>

<h2>Prototipo de un Sistema de Alerta Sísmica</h2>

<h3>Mexicanas del Futuro - Caravanas IPN</h3>

<h4>Agosto, 2018</h4>

<h2>1. Introducción</h2>

<p>La Internet de las Cosas (IoT, <em>Internet of Things</em>) tendrá un profundo impacto en prácticamente todas las actividades de nuestra vida.  </p>

<p>Para sacar provecho de lo que los objetos <em>inteligentes</em> perciben, es necesario contar con una plataforma que permita capturar, procesar, mostrar y almacenar los datos capturados por esos objetos.</p>

<p>En este taller tendremos una primera exposición a <strong>Fiware</strong>, una plataforma abierta que permite desplegar aplicaciones <em>inteligentes</em> muy rápidamente.  Específicamente, estaremos interactuando con su componente central, el <strong>Orion Context Broker</strong> (OCB), que es el encargado de recibir los datos enviados por los objetos de interés.</p>

<p>Como aplicación <em>inteligente</em> implementaremos una maqueta de un Sistema de Alerta Sísmica (SAS) que estará conformado por:</p>

<ul>
<li>Sensores de movimiento conectados a placas Arduino para simular movimientos telúricos</li>
<li>Un nodo colector de datos (el Orion Context Broker de Fiware)</li>
<li>La lógica para discriminar si se debe reportar un sismo, o simplemente registrar el movimiento telúrico</li>
<li>Una estación de monitoreo que reportará con un código de colores la presencia o ausencia de sismos.</li>
</ul>

<h2>2. Objetivo</h2>

<p>El objetivo central de este tutorial es dar una idea básica del flujo de datos típico al implementar aplicaciones inteligentes que utilicen información obtenida de diferentes medios como sensores, usuarios de dispositivos móviles, etcétera. </p>

<p>Los objetivos particulares son:</p>

<ul>
<li>Familiarizarse con los conceptos del Orion Context Broker en un entorno IoT.<br></li>
<li>Implementar un prototipo de sensor de movimiento con una tarjeta Arduino</li>
</ul>

<p>Este taller es muy ambicioso e incluye algunos conceptos no triviales; siéntase en libertad de darle un primer recorrido rápido, enfocarse en los temas que le sean de mayor interés en una primera fase, y volver a él con más calma al terminar el taller.  </p>

<h2>3. Sistema de Alerta Sísmica</h2>

<p>La siguiente figura muestra el diagrama del Sistema de Alerta Sísmica de México.</p>

<!---
!["imagen del SAS"](../imagenes/Sasmex.jpg)
--->

<p><img src="https://i.imgur.com/1UvoxjU.jpg" alt="Imgur"></p>

<p>Cuando inicia un temblor, se generan dos tipos de onda. Las ondas P se propagan muy rápidamente pero casi nunca generan daños. Las ondas S viajan mucho más despacio y son las que provocan los desastres si tienen la energía suficiente.  </p>

<p>En un movimiento telúrico, los {\it Field Sensors} (FS) detectan las ondas P (de hecho, la diferencia entre las ondas P y S), hacen un primer procesamiento y mandan información a través de la red de comunicaciones, al sistema de control central.  </p>

<ul>
<li><em>En este taller, los FS se simularán con unos sensores de movimiento inercial (IMU) minIMU-04 conectados a una placa Arduino YÙN donde se hará el procesamiento inicial y, si se detecta movimiento, se enviará al sistema de control a través de una conexión WiFi.</em></li>
</ul>

<p>El sistema central analiza la información de los sensores junto con otra información y decide si debe emitir la alerta sísmica.  Por ejemplo, en el SAS de México, la alerta se emite sólo si al menos cinco FS en la misma zona detectaron el movimiento y si éste es mayor de 4.5 grado Richter.</p>

<ul>
<li><em>En este taller, el sistema central estará simulado por el Orion Context Broker, que recibe la  información de los sensores a través de Arduino, y de la &quot;lógica de negocio&quot; implementada en un programa que decide si debe emitir una alerta cuando al menos tres sensores de la misma zona reportan un movimiento considerable.</em></li>
</ul>

<p>Si la alerta debe activarse, el sistema de control central envía notificaciones a las estaciones de radio y TV de la Ciudad de México, a proveedores de telefonía celular para aquellos abonados que tengan la aplicación, y a otros centros de difusión.</p>

<ul>
<li><p><em>En este taller, la alerta se desplegará en una estación de monitoreo con un código de colores por zona:</em> </p></li>
<li><p><em>Verde si en la zona ningún FS detectó movimientos</em></p></li>
<li><p><em>Amarillo si uno o dos FS en la zona detectaron movimientos</em></p></li>
<li><p><em>Rojo si al menos tres FS en la zona detectaron movimientos</em></p></li>
</ul>

<h2>4. Desarrollo</h2>

<h3>4.1 Placa Arduino y sensor.</h3>

<p>Arduino es probablemente la plataforma de hardware abierto más popular para desarrollo y prototipado rápido de proyectos de sistemas digitales.  Ha logrado conformar una amplísima comunidad de desarrolladores que comparten las especificaciones y el código de sus proyectos.</p>

<p>La plataforma tiene una serie de interfaces entrada y salida (E/S) que pueden ser programadas para monitorear (con ayuda de sensores) o interactuar (con ayuda de actuadores) con su entorno.  La figura siguiente muestra la tarjeta Arduino YÚN, que es la que se utilizará en estas prácticas. La gran ventaja de esta tarjeta es que ya tiene integrada una interfaz WiFi.</p>

<p><img src="https://i.imgur.com/Kzb5AOl.png" alt="Imgur"></p>

<p>Arduino cuenta con un ambiente de desarrollo integrado (IDE, <em>Integrated Development Environment</em>) para programar las acciones que se desean configurar en la placa.  Los programas (llamados <em>sketch</em>) escritos en el IDE se descargan a la placa a través de la interfaz USB. </p>

<p>Hay una gran variedad de sensores (por ejemplo, de temperatura, humedad, iluminación, sonido, contaminantes, nutrientes, posicionamiento, velocidad, …) y actuadores (por ejemplo, LEDs, zumbadores, relevadores, acopladores, …) que pueden conectarse a una placa Arduino a través de sus interfaces programables E/S. Como hemos mencionado, en este taller usaremos el IMU04 para simular un <em>Field Sensor</em> del Sistema de Alerta Sísmica.  </p>

<h4>4.1.1. Instalación del IDE y detección de la placa Arduino</h4>

<p>El IDE permite expresar un programa en un lenguaje muy parecido a C que se compila en el lenguaje de máquina del micro-controlador de la placa.</p>

<ul>
<li>(1) Conecta la placa a un puerto USB de tu computadora.  Se deberá encender un LED verde indicando que la placa está energizada (aproximadamente un min).</li>
<li>(2) Ahora vamos a conectar el sensor de movimiento a la placa Arduino como se muestra en la figura siguiente:</li>
</ul>

<p><img src="https://i.imgur.com/7uR3Eyo.jpg" alt="&quot;Figura de conexión del sensor, leds y placa&quot;"></p>

<p>En el IDE de Arduino:</p>

<ul>
<li>(3) Selecciona Tools -&gt; Port y selecciona el puerto en donde esté el Arduino Yun. En la siguiente figura, está conectado al puerto COM6.</li>
</ul>

<p><img src="https://i.imgur.com/79XJIZu.png" alt="Imgur"></p>

<p>Al final de este tutorial, en la sección *<em>Sketch Sensor IMU</em> encontrarás un programa que contiene una serie de funciones para que no invirtamos demasiado tiempo con los detalles de la programación y configuración de los sketch. </p>

<ul>
<li>(4) Selecciona File -&gt; New. Aparece una ventana para escribir un nuevo sketch</li>
</ul>

<p><img src="https://i.imgur.com/jP3nuJ3.jpg" alt="Imgur"></p>

<ul>
<li><p>(5) Borra su contenido y sustitúyelo por el código del Sketch Sensor IMU.</p></li>
<li><p>(6) Ahora sigue las indicaciones del instructor para que puedas configurar tu placa con los parámetros de tu zona (identificador de FS y zona) y para que puedas hacer un pequeño programa que lee los movimientos del sensor.</p></li>
<li><p>(7) Da clic en la flecha que se encuentra arriba al lado izquierdo para compilar y transferir este sketch a la tarjeta. Espera a que se vea el mensaje <em>Done uploading</em>. </p></li>
</ul>

<p><img src="https://i.imgur.com/Edt7ZOc.png" alt="Imgur"></p>

<ul>
<li>(8) Ahora da clic en la lupa que se encuentra arriba del lado derecho para abrir el monitor serie. </li>
</ul>

<p><img src="https://i.imgur.com/xVwt2Sc.png" alt="Imgur"></p>

<ul>
<li>(9) Toma la tarjeta protoboard donde se encuentra el sensor y agítala levemente, o un poco mas fuerte.  Podras observar en el monitor que cada segundo se toma una lectura del sensor y ésta se reporta al monitor en caso de que haya detectado movimientos.</li>
</ul>

<p><strong>¡FELICIDADES.  Ya tienes un nodo sensor de movimiento funcionando!</strong></p>

<h4>4.1.2. Conexión de la placa Arduino YÙN a la red WiFi/Internet del laboratorio</h4>

<p>Para poder enviar las lecturas del sensor a nuestro sistema de control, primero debemos conectar la placa Arduino a la red local WiFi del laboratorio.  A través de esta red podremos enviar las lecturas al sistema de control.</p>

<p>Nuestra placa YÙN contiene un puerto WiFi al que se pueden conectar otras computadoras.  Nos vamos a conectar a través de él para indicarle que en realidad queremos que la placa se conecte a la red del laboratorio.</p>

<p>** El siguiente paso puede ser un poco confuso porque no conocemos  qué red pertenece a qué placa**.  Podemos apagar todas las placas e ir configurando una a una, o simplemente podemos ir acoedando qué equipo va a configurar qué placa.</p>

<ul>
<li><p>(1) En tu computadora portátil (o desde tu celular), encuentra un identificador de red WiFi de un Arduino. Se identifica por <em>Arduino Yun-XXXXXXXXXXXX</em> (las XX representan números hexadecimales).</p></li>
<li><p>(2) Haz que tu dispositivo se conecte a esa red.</p></li>
</ul>

<p><img src="https://i.imgur.com/JBBCiCo.jpg" alt="Imgur"></p>

<ul>
<li><p>(3) Ahora que tu dispositivo está en la red del Arduino, conéctate a un pequeño servidor que tiene la placa para configurarlo.  En un navegador, en la pestaña del URL escribe 192.168.240.1</p></li>
<li><p>(4) Aparecerá una pantalla solicitando una contraseña. Escribe <strong>arduino</strong> y en nueva pantalla, selecciona el botón <strong>CONFIGURE</strong>.</p></li>
</ul>

<p><img src="https://i.imgur.com/YhTlJ4N.jpg" alt="Imgur"></p>

<ul>
<li><p>(5) En la ventana de configuración, en la parte inferior <em>WIRELESS PARAMETERS</em>  selecciona el menú de <em>DETECTED WIRELESS NETWORKS</em> y da clic en la red del Laboratorio (el instructor te indicara cuál es).</p></li>
<li><p>(6) Ahora da clic en <em>CONFIGURE &amp; RESTART</em> y espera a que la nueva configuración se haya completado.</p></li>
<li><p>(7) Mientras tanto, conecta también tu dispositivo a la red del Laboratorio.</p></li>
<li><p>(8) Sigue las indicaciones de tu instructor para modificar tu sketch para que envíe las lecturas al Orion Context Broker (OCB), quien funge como el punto de entrada del sistema de control.</p></li>
</ul>

<h3>4.2. Envío de lecturas al Orion Context Broker</h3>

<p>En el <strong>Apéndice</strong> de este tutorial encontrarás un poco de información sobre el <em>Orion Context Broker</em> (OCB) de Fiware.  Por ahora es suficiente con señalar que el OCB es un componente esencial de la plataforma.  Es un intermediario entre los productores de datos (nuestro sensor y la placa Arduino) y los consumidores de éstos (nuestro programa para implementar la lógica que decide si hay que activar o no una alerta, y el tablero de mando).</p>

<p><img src="https://i.imgur.com/rci7Co3.png" alt=""></p>

<p>La información se envía y se consulta del OCB en formato JSON siguiendo una especificación muy precisa, a través de una interfaz de programación (API, <em>Application Programming Interface</em>). </p>

<p>Cuando agitamos el sensor de movimiento, nuestro Arduino no sólo reporta la magnitud en el monitor serie; también envía un mensaje al OCB en donde se almacena el último dato enviado por cada estación de monitoreo.</p>

<p>En este taller solamente consultaremos al OCB para verificar que las lecturas (la última lectura) que envía nuestro sensor, efectivamente se registran en él.  Para ello, vamos a utilizar llamado <em>Insomnia</em> que nos permite enviar comandos del protocolo HTTP (<em>Hypertext Transfer Protocol</em>), que es como se interactúa con el OCB.</p>

<p>Para poder interactuar con el OCB utilizaremos la herramienta <a href="https://insomnia.rest/">Insomnia</a>. Si lo deseas, puedes utilizar cualquier otro cliente REST.</p>

<p>Para obtener información de la base de datos en el OCB se utiliza el método <strong>GET</strong> de HTTP. </p>

<ul>
<li>(1) Abre el programa <em>Insomnia</em>  y da clic en <strong>New Request</strong></li>
</ul>

<p><img src="https://i.imgur.com/xPddIY3.png" alt="&quot;Nueva carpeta insomnia&quot;"> </p>

<ul>
<li><p>(2) Asigna un nombre a tu consulta (por ejemplo, consulta del equipo xx).  Observa que por default, el tipo de comando que te propone Insomnia es GET.</p></li>
<li><p>(3) Para el método GET,  sólo se especifica el URL, sin Body ni Content-type. En nuestra primer consulta pediremos todas las entidades almacenadas en el OCB hasta ahora.  Para ello, el URL que se utiliza es: <code>http://XX.XX.XX.XX:1026/v2/entities</code>, donde las XX.XX se sustituyen por la dirección IP que te indique el instructor. </p></li>
</ul>

<p>Observa del lado derecho el resultado de la consulta.</p>

<p><img src="https://i.imgur.com/9po7gwI.png" alt="&quot;Insomnia obtén todas&quot;"> </p>

<h5>Consulta acotada.</h5>

<p>Podemos consultar una sola entidad agregando el identificador de esa entidad al final del URL.</p>

<ul>
<li>(4) Haz una nueva consulta o modifica la que ya tienes.  Lo único que debes hacer es extender el URL con el ID de tu entidad </li>
</ul>

<h1>Aquí necesito el JSON para hacer una consulta acotada específica a la zona</h1>

<pre><code class="javascript">GET URL/v2/entities/{entityID}/
</code></pre>

<ul>
<li>(5) Agita tu sensor de movimiento para asegurar que llegó una notificación al OCB y lanza nuevamente la consulta.</li>
</ul>

<p>Repite varias veces la consulta agitando con distinta intensidad tu sensor.</p>

<h3>4.3 El sistema de control</h3>

<p>Por falta de tiempo, tus instructores han implementado para tí la &quot;lógica de negocio&quot; del SAS que describimos en la introducción.  Básicamente, se trata de un programa que toma las lecturas del OCB y verifica si algún sensor reporta un movimiento telúrico.  De ser así, y si el movimiento rebasa un cierto umbral, lo reporta en la estación de monitoreo representando el fenómeno con un color.</p>

<p>Si es uno o dos sensores de la misma zona, ésta cambiará de color Verde a color Amarillo, pero si son tres o más los sensores que detectaron un movimiento considerable, entonces la zona se colorea de Rojo y simboliza que se está emitiendo una alerta sísimica.</p>

<ul>
<li>Identifica quiénes son tus compañeras de zona y coordínate con ellas para que consigan hacer pasar su zona de Verde a Amarillo y finalmente a Rojo.</li>
</ul>

<h3>Conclusión</h3>

<p>Hemos llegado al final de nuestro taller.  Esperamos que hayas disfrutado tu estancia con nosotros y, aunque tengas todavía algunas dudas por lo breve que fue este taller, esperamos que hayas podido asimilar los principios básicos de operación de las plataformas para Internet de las Cosas y de cómo las Tecnologías de Información y de Comunicaciones nos ayudan a salvar miles de vidas en casos de desastres naturales como son los terremotos.</p>

<p><strong>¡MUCHAS FELICIDADES!</strong>  Lograste mucho en muy poco tiempo. ¿Te imaginas todo lo que puedes hacer al explorar un poquito más estas tecnologías?  ¡No dudes en contactarnos si tienes alguna duda!</p>

<h2>Apéndice.- Orion Context Broker</h2>

<p>En Fiware, para que las aplicaciones puedan obtener información de los sensores y objetos inteligentes, un componente esencial es el Orion Context Broker (OCB). Orion Context Broker es una implementación de la API NGSI (<em>Next Generation Service Interface</em>) que permite manejar y asegurar la disponibilidad de la información obtenida del contexto donde se encuentra el objeto (el sensor). La versión que se utiliza actualmente es <strong>NGSIv2</strong>.</p>

<p>La especificación completa de NGSIv2 se encuentra aquí: <a href="http://fiware.github.io/context.Orion/api/v2/stable/">http://fiware.github.io/context.Orion/api/v2/stable/</a>.</p>

<p>La interacción típica en la plataforma Fiware (como en la mayoría de las plataformas para Internet de las Cosas) consta de tres elementos: el productor de información de contexto (por ejemplo, un sensor), un intermediario, que en nuestro caso es el OCB, y el consumidor de esa información.</p>

<p><img src="https://i.imgur.com/rci7Co3.png" alt=""> </p>

<p>El productor de información de contexto se encargará de crear nuevas entidades o de actualizar las entidades ya existentes. Típicamente accede al OCB a través del <strong>puerto 1026</strong>.</p>

<p>Los últimos datos se mantienen persistentes en el OCB con ayuda de una base de datos; en nuestro caso, se utiliza MongoDB.</p>

<p>El OCB funciona como intermediario entre los productores de información y otros componentes (los consumidores de información) como pueden ser un tablero de mando para representar gráficamente la información, un conector hacia bases de datos o repositorios de big data, un procesador en tiempo real, etcétera.</p>

<p>En este tutorial vamos a interactuar con el OCB enviando y consultando representaciones de objetos a través de una API REST.</p>

<h3>Representación de datos de contexto</h3>

<p>Para representar objetos de la vida real se utiliza el modelo de entidades de la API NGSI. En éste se define un <strong>modelo de datos</strong> de información de contexto basado en <em>entidades</em> y en <em>atributos</em>. Cada entidad representa un objeto de la vida real y puede tener atributos y metadatos.</p>

<p>Las entidades cuentan con un identificador (ID) y un tipo. <strong>Esta pareja ID/tipo debe ser única en el OCB</strong>.  Los atributos y metadatos se representan por una tupla <strong>[nombre, tipo, valor]</strong>. </p>

<p>Todos los datos estarán representados con el formato JSON (también podrían representarse en otro formato, por ejemplo, key/value). El formato de datos <strong>JSON (Java Script Object Notation)</strong> es ligero para el intercambio de información, además de ser fácil de leer, así como de procesar.</p>

<p>Un Objeto JSON tienen las siguiente forma:</p>

<p><img src="https://i.imgur.com/85GbVzq.gif" alt="&quot;Imagen tomada de JSON.org&quot;"> </p>

<p>Es decir, se encuentran definidos entre llaves. <em>String</em> será definido como las propiedades entidades. Los <em>value</em> son los atributos.</p>

<p>Por ejemplo, modelaremos la temperatura y la presión de un cuarto con la siguiente entidad:</p>

<pre><code>{
    &quot;id&quot;: &quot;Cuarto1&quot;
    &quot;type&quot;: &quot;Cuarto&quot;
    &quot;temperature&quot;: {
        &quot;type&quot;: &quot;Float&quot;,
        &quot;value&quot;: 23,
        &quot;metadata&quot;:{
            “precision”: {
                “type”:xxx,
                “value”: xxx
            }
        }
    },
    &quot;pressure&quot;:{
        &quot;value&quot;: 720
    }
}
</code></pre>

<p>Como se observa en el ejemplo anterior, en los atributos se puede especificar o no el tipo de dato. Se recomienda especificarlo siempre; si se omite, el OCB tratará de inferirlo.  </p>

<p>También se observa que la metadata es opcional y en caso de exisitir, su formato será también una tupla [nombre, tipo, valor].</p>

<p><em>Nota:</em> Fiware ya tiene un conjunto de modelos estandarizados. Pueden consultarse en la página <a href="https://www.fiware.org/data-models/">https://www.fiware.org/data-models/</a>. Otra página de interés es <a href="http://schema.org/">http://schema.org/</a>. Si se encuentra un modelo del objeto que deseamos representar, conviene utilizar esos esquemas para que nuestro producto sea interoperable.</p>

<h3>Interactuando con el OCB</h3>

<p>El OCB contiene una interfaz tipo Web para realizar las consultas a la base de datos MongoDB. Se trata de un servicio web de tipo REST (Representational state transfer). </p>

<p>En este tutorial, la interacción con el OCB se hará a través de solicitudes HTTP con un cliente REST. Para ello, se debe especificar el URL al cual estaremos haciendo la solicitud, el método REST de la solicutud, el encabezado y el cuerpo de la solicitud.</p>

<p>Este tipo de servicios permiten obtener información de forma arborecente. Es decir, es posible obtener | actualizar | borrar información de una entidad completa o sólo valores de una entidad en específico.</p>

<p>El URL al que haremos la solicitud sera: <strong><a href="http://XX.XX.XX.XX:1026/v2/">http://XX.XX.XX.XX:1026/v2/</a>...</strong>, es decir, la comunicación se hace a través del puerto 1026 y utilizando la versión 2 de la NGSI.</p>

<p><strong>(<em>Sustituya las XX.XX.XX.XX por la dirección IP de su instancia si la instaló como se indica en la cuarta parte de este tutorial, o la dirección IP del servidor que se le indique en la sala</em>.)</strong> </p>

<p>Los métodos REST que utilizaremos son <strong>GET, POST, PUT, DELETE, OPTIONS, HEAD, TRACE, CONNECT.</strong>  </p>

<p>El encabezado de la consulta indica en qué formato se estará recibiendo y enviando la información: </p>

<ul>
<li>Si la información es de tipo JSON se debe poner <strong>application/json</strong> </li>
<li>Si es de tipo texto se debe de poner <strong>text/plain</strong>.</li>
</ul>

<p>Para indicar que se está enviando información se debe de poner <strong>Content-Type</strong> y para indicar que se desea recibir se debe de poner <strong>Accept</strong>.  </p>

<p>Así, una solicitud quedaría de la siguiente manera: </p>

<pre><code>xx.xx.xx:pto/v2/entities
Método: POST
Headers: Content-Type:application/json
Body:
{  “id”: xx
   “type”: xx
   “atributo”:{
        &quot;value&quot;:xx
   }
   ...
}
</code></pre>

<p>Para poder interactuar con el OCB utilizaremos la herramienta <a href="https://insomnia.rest/">Insomnia</a>. Si lo desea, puede utilizar cualquier otro cliente REST.  De hecho, se puede hacer desde la terminal de git con el comando <em>curl</em>, pero ello es mucho más propenso a errores.</p>

<p>Crearemos en insomnia una carpeta llamada <strong>Operaciones-Comunes</strong>. En esta carpeta se guardarán todas las consultas que hagamos.</p>

<p><img src="https://i.imgur.com/xPddIY3.png" alt="&quot;Nueva carpeta insomnia&quot;"> </p>

<h4>POST</h4>

<p>En primer lugar debemos enviar la representación de una entidad con el método <strong>POST</strong>:
Comenzaremos por crear una nueva petición (New Request) en Insomnia:</p>

<p><img src="https://i.imgur.com/feKIvNj.png" alt=""> </p>

<p>El nombre sugerido para esta petición es <strong>inserta-entidad</strong>, el método que utilizaremos será <strong>POST</strong> y el cuerpo (body) será de tipo JSON.</p>

<p>El URL que utilizaremos será <strong><a href="http://XX.XX.XX.XX:1026/v2/entities">http://XX.XX.XX.XX:1026/v2/entities</a></strong> y el tipo de encabezado será <em>application/json</em>. En Insomnia se establece automaticamente cuando seleccionamos JSON como el tipo de dato (en algunas operaciones posteriores, utilizaremos un body tipo <em>text/plain</em>).</p>

<pre><code>{
        &quot;id&quot;: &quot;Room01&quot;,
        &quot;type&quot;: &quot;Room&quot;,
        &quot;floor&quot; :{
            &quot;value&quot;:&quot;PB&quot;,
            &quot;type&quot;:&quot;text&quot;
        },
        &quot;temperature&quot; :{
            &quot;type&quot;: &quot;Float&quot;,
            &quot;value&quot;: 23
        }
    }
</code></pre>

<p>En el cuerpo de la consulta, en la parte media de Insomnia, colocaremos la descripción de la entidad.</p>

<p>Si todo está correcto, al dar <code>Send</code> en el extremo derecho de Insomnia se debe observar el mensaje <code>201 CREATED</code> y el cuerpo de la respuesta debe estar vacío.</p>

<h4>GET</h4>

<p>Para obtener información de la base de datos en el OCB se utiliza el método <strong>GET</strong>. </p>

<p>En Insomnia, es posible duplicar la consulta anterior y renombrarla. Hágalo así y nombre la nueva consulta <code>obten-todas-entidades</code>. Por supuesto, debe modificar el método de POST a GET.</p>

<p>Para el método GET,  sólo se especifica el URL, sin Body ni Content-type. En nuestra primer consulta pediremos todas las entidades almacenadas en el OCB hasta ahora.  Para ello, el URL que se utiliza es: <code>http://XX.XX.XX.XX:1026/v2/entities</code>: </p>

<p><img src="https://i.imgur.com/9po7gwI.png" alt="&quot;Insomnia obtén todas&quot;"></p>

<h5>Consulta acotada.</h5>

<p>Podemos consultar una sola entidad agregando el identificador de esa entidad al final del URL.</p>

<p><img src="https://i.imgur.com/PaFOMbA.png" alt="Insomnia obten-una-entidad"></p>

<p>De forma similar, a partir de la versión 2 de NGSI es posible realizar consultas (u otros métodos como PUT y DELETE) a atributos de las entidades ampliando el URL:</p>

<pre><code class="javascript">GET URL/v2/entities/{entityID}/attrs/{attrName}
</code></pre>

<p>Por ejemplo, para ver el atributo &quot;temperature&quot; de la entidad Room01, se utiliza el URL <code>http://XX.XX.XX.XX:1026/v2/entities/Room01/attrs/temperature/</code>, y si se desea únicamente su valor, se extiende el URL hasta: <code>http://XX.XX.XX.XX:1026/v2/entities/Room01/attrs/temperature/value/</code>.</p>

<h3>Actualización de valores</h3>

<p>Si deseamos actualizar los valores de los atributos de una entidad que ya se encuentra en el OCB, se utiliza el método <strong>PUT</strong>.  Cuando se actualizan los valores de varios atributos a la vez, se utiliza el URL hasta el identificador de la entidad y en el cuerpo se especifican los nuevos valores en formato JSON.</p>

<p>En el siguiente ejemplo, se modificarán únicamente los valores de los atributos <em>frequency</em> y <em>current</em> de la entidad <em>Med024</em>:</p>

<pre><code class="bash">Método: PUT
{url}/v2/entities/{id}/attrs/{value}
</code></pre>

<p>Así tenemos:</p>

<pre><code>http://XX.XX.XX.XX:1026/v2/entities/Room01/attrs/temperature
Método: PUT
Headers: Content-Type:application/json
Body;

    {
        &quot;type&quot;: &quot;Float&quot;,
        &quot;value&quot;: 19 
    }
</code></pre>

<p><img src="https://i.imgur.com/4BLssjs.png" alt=""> </p>

<p>Para verificar el cambio se puede volver a hacer el método GET en donde veremos que el valor del atributo ha cambiado. </p>

<p><img src="https://i.imgur.com/GeDoicf.png" alt=""> </p>

<p>Con este método, si se omite un attributo, éste desaparece de la entidad. Si lo que se desea es actualizar únicamente alguno o algunos de los atributos, el método que debe usarse es <strong>PATCH</strong>.  Por ejemplo, si sólo se desea actualizar temperature Room01, la consulta se hará así:</p>

<pre><code class="bash">Método: PATCH
URL: http://XX.XX.XX.XX:1026/v2/entities/Room01/attrs

Body:
{
    "temperature":{
        "value":22.2,
        "type":"Float"
    }
}

Header: Content-type:  application/json
</code></pre>

<p>Frecuentemente, lo que se desea es actualizar únicamente el valor de un atributo. En este caso, como se hizo anteriormente, se extiende el URL hasta {attrId}/value y en el cuerpo del mensaje se coloca el valor, especificando que el tipo de contenido es texto plano.</p>

<h3>Delete</h3>

<p>El método DELETE permite eliminar entidades y atributos.</p>

<p>Para borrar un atributo se utiliza el comando Delete:</p>

<pre><code>delete http://url:1026/v2/entities/{id}/attrs/{value}
</code></pre>

<p>Para borrar una se utiliza la siguiente expresión:</p>

<pre><code>delete http://url:1026/v2/entities/{id}
</code></pre>

<p>Para probar este método, creemos una nueva entidad:</p>

<pre><code class="bash">{
  <span class="string">"id"</span>:<span class="string">"talentland"</span>,
  <span class="string">"type"</span>:<span class="string">"prueba"</span>,
  <span class="string">"temp"</span>:{
    <span class="string">"value"</span>:24,
    <span class="string">"type"</span>:<span class="string">"integer"</span>
  },
  <span class="string">"NumGente"</span>:{
    <span class="string">"type"</span>:<span class="string">"integer"</span>,
    <span class="string">"value"</span>:607
  }
}
</code></pre>

<p><strong>¡Felicidades!</strong> Ahora se ha familiarizado con las principales funcionalidades del Componente Orion Context Broker.</p>

<h2>Sketch Sensor IMU</h2>

<pre><code class="java">* Lee datos del IMU<span class="number">0</span><span class="number">4</span> y los reporta
 *  como si fueran generados por un Field Sensor en 
 *  un Sistema de Alerta Sismica
 */

#include &lt;Bridge.h&gt;
    #include &lt;Process.h&gt;  
    #include &lt;Wire.h&gt;
    #include &lt;LSM<span class="number">3</span><span class="number">0</span><span class="number">3</span>.h&gt;

    <span class="comment">// apcicipn</span>

    LSM<span class="number">3</span><span class="number">0</span><span class="number">3</span> compass;
    <span class="keyword">int</span> ejex, ejey, ejez;
    <span class="keyword">int</span> mascara = <span class="number">65520</span>; 
    String var, add, method, header,json;
    bool bandera;
    bool temblor = <span class="keyword">false</span>;


    <span class="comment">//Cambiar estos valores</span>
    String zona  = <span class="string">""</span>;
    String id = <span class="string">""</span>;
    String dirIP = <span class="string">":1026"</span>;


    <span class="keyword">void</span> setup()
    {
      <span class="comment">// Las funciones de configuración van aqu�</span>� 


       dela<span class="number">y(10</span><span class="number">0</span><span class="number">0</span>);
    }

    <span class="keyword">void</span> loop()
    {

      // Llama aquí la función para encender el LED

      //Las funciones de acción van aquí 


      delay(2000);

      if(temblor){
         // ¿Qué debes hacer si se detecta un temblor?
      }

      delay(500<span class="number">0</span>);
    }





    //########################################################################################################
    // Funciones a utilizar

    //Fucnión que enciende LED
    void encenderLED(){
      digitalWrite(LED_BUILTIN, HIGH);   
      delay(1000);                       
      digitalWrite(LED_BUILTIN, LOW);    
    }

    // Función que enciende el sensor para utilizarlo
    void encenderSensor(){
      Serial.begin(960<span class="number">0</span>);
      Bridge.begin();
      Wire.begin();
      compass.init();
      compass.enableDefault();
      pinMode(LED_BUILTIN, OUTPUT);
    }

    //Función que lee los datos del sensor y los imprime
    void leerDatos(){
      compass.read();

      ejex = (compass.a.x &amp; mascara)&gt;&gt;<span class="number">4</span>;
      ejey = (compass.a.y &amp; mascara)&gt;&gt;<span class="number">4</span>;
      ejez = (compass.a.z &amp; mascara)&gt;&gt;<span class="number">4</span>;

      <span class="keyword">if</span>(ejex&lt;<span class="number">0</span>)
        ejex = -ejex;
      <span class="keyword">if</span>(ejey&lt;<span class="number">0</span>)
        ejey = -ejey;
      <span class="keyword">if</span>(ejez&lt;<span class="number">0</span>)
        ejez = -ejez;
      Serial.println(ejex);
      Serial.println(ejey);
    }


   // Función que comprueba si hay un temblor
    void comprobarTemblor(){
       if(ejex &gt;= 50<span class="number">0</span>){
        Serial.println(<span class="string">"temblor trepidatorio sobre x");
        enviarDatosTemblor(ejex);
        temblor = true;
        bandera = false;
       }

      if(ejey&gt;= 500&amp;&amp; bandera){
        Serial.println("temblor trepidatorio sobre y");
        enviarDatosTemblor(ejey);
        temblor = true;

      }
      bandera = true;
    }


    //Función que envía la magnitud de un temblor
    void enviarDatosTemblor(int magnitud){
        Process p;
        p.begin("curl");
        p.addParameter("-H");
        p.addParameter("Content-Type: application/json");
        p.addParameter("-X");
        p.addParameter("PUT");
        p.addParameter("-d");
        json = "{\"value\":"+(String)magnitud+"}";
        Serial.println(json);
        p.addParameter(json);
        p.addParameter("-k");
        p.addParameter("http://"+dirIP+"</span>/v<span class="number">2</span>/entities/<span class="string">"+id+"/attrs/temblor");
        p.run();
        while (p.available() &gt; 0) {
          char c = p.read();
          Serial.print(c);
        }
        Serial.println("Terminé enviar datos");
        Serial.flush();
        p.close();
    }


        //Función que regresa los valores del temblor a cero para poder recibir nuevos datos. 
        void regresarValoresIniciales(){
        Process p;
        temblor = false;
        p.begin("curl");
        p.addParameter("-H");
        p.addParameter("Content-Type: application/json");
        p.addParameter("-X");
        p.addParameter("PUT");
        p.addParameter("-d");
        json = "</span>{\"value\<span class="string">":0}";
        Serial.println(json);
        p.addParameter(json);
        p.addParameter("-k");
        p.addParameter("</span>http://<span class="string">"+dirIP+"/v2/entities/SensorSismico2/attrs/temblor");
        p.run();
        while (p.available() &gt; 0) {
          char c = p.read();
          Serial.print(c);
        }
        Serial.flush();
        p.close();
    }


    //Función que registra al sensor en el servidor
    void registrarSensor(){
        Process p;
        Serial.println("Registro de sensor");
        p.begin("curl");
        p.addParameter("-H");
        p.addParameter("Content-Type: application/json");
        p.addParameter("-X");
        p.addParameter("POST");
        p.addParameter("-d");
        p.addParameter("{</span>\<span class="string">"id\": "</span>+id+<span class="string">",\"type\":</span>\<span class="string">"SensorSismico\",\"temblor\":{\"value\":0},\"zona\":{\"value\":"+zona+"}}");
        p.addParameter("-k");
        p.addParameter("http://"+dirIP+"/v2/entities");
        p.run();
        while (p.available() &gt; 0) {
          char c = p.read();
          Serial.print(c);
        }
        Serial.println("</span>Terminé regsitro<span class="string">");
        Serial.flush();
        p.close();
        return;
    }
</code></pre>

</body>
</html>